/*
 * SPDX-License-Identifier: Apache-2.0
 * SPDX-FileCopyrightText: Huawei Inc.
 */

package org.eclipse.xpanse.modules.security.hmac;

import jakarta.servlet.http.HttpServletRequest;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Objects;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.codec.binary.Hex;
import org.apache.commons.codec.digest.HmacAlgorithms;
import org.eclipse.xpanse.modules.models.common.exceptions.ClientAuthenticationFailedException;
import org.eclipse.xpanse.modules.models.common.exceptions.XpanseUnhandledException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.util.StreamUtils;

/**
 * HMAC Signature must in the format - x-signature: algorithm=HmacSHA256;headers=x-nonce-signature
 * x-timestamp-signature;signature=d4fb456bc7621ed1c8099e8a1136997d6ad9b8613fc79a49b39833d4cb36080a
 * algorithm - Name of the algorithm used by the client to generate signature. headers - other
 * header values that are used by the client to generate signature. signature - actual signature
 * generated by encrypting plain text which contains newline separated data from mentioned headers,
 * URL, payload.
 */
@Slf4j
@Component
public class HmacSignatureHeaderManage {

    private static final String MAIN_SIGNATURE_HEADER = "x-signature";
    private static final String ALGORITHM_KEY = "algorithm";
    private static final String HEADERS_USED_IN_SIGNATURE_KEY = "headers";
    private static final String SIGNATURE_KEY = "signature";
    private final String hmacSecretKey;
    private static final String SIGNATURE_HEADER_SEPARATOR = ";";
    private static final String SIGNATURE_HEADER_KEY_VALUE_SEPARATOR = "=";
    private static final String SIGNATURE_CONTENT_VALUES_SEPARATOR = "\n";
    // separator between the list of header names that are part of the generated signature.
    private static final String SIGNATURE_HEADERS_LIST_SEPARATOR = " ";

    /** constructor for HmacSignatureHeaderManage. */
    @Autowired
    public HmacSignatureHeaderManage(
            @Value("${xpanse.webhook.hmac.request.signing.key}") String hmacSecretKey) {
        this.hmacSecretKey = hmacSecretKey;
        if (hmacSecretKey.isBlank()) {
            throw new IllegalArgumentException("hmacSecretKey is blank");
        }
    }

    /** Extracts signature data from the HTTP request and validates it. */
    public boolean validateHmacSignature(RereadbleBodyHttpServletRequest httpRequest)
            throws ClientAuthenticationFailedException, IOException {
        String requestBody =
                StreamUtils.copyToString(httpRequest.getInputStream(), StandardCharsets.UTF_8);
        String url = httpRequest.getRequestURL().toString();
        String queryString = httpRequest.getQueryString();
        if (queryString != null) {
            url += "?" + queryString;
        }
        if (Objects.nonNull(httpRequest.getHeader(MAIN_SIGNATURE_HEADER))) {
            // get details from x-signature header value.
            String[] signatureHeader =
                    httpRequest.getHeader(MAIN_SIGNATURE_HEADER).split(SIGNATURE_HEADER_SEPARATOR);

            String algorithmUsedToSign =
                    getDetailsFromHmacSignatureHeader(signatureHeader, ALGORITHM_KEY);
            String[] headersUsedInSignature =
                    getDetailsFromHmacSignatureHeader(
                                    signatureHeader, HEADERS_USED_IN_SIGNATURE_KEY)
                            .split(SIGNATURE_HEADERS_LIST_SEPARATOR);
            validateAlgorithmName(algorithmUsedToSign);

            // get values of headers that are claimed to be used in the signature generation.
            String headerValuesUsedInSignatureGeneration =
                    groupHeaderValueContent(httpRequest, headersUsedInSignature);

            // get the full plaintext that must be used to generate signature.
            String fullSignaturePayload =
                    getSignatureValue(headerValuesUsedInSignatureGeneration, url, requestBody);
            log.debug("Values used to generate HMAC signature: {}", fullSignaturePayload);

            // get the signature from the payload to compare with the signature sent from client.
            String generatedSignature = signRequestData(algorithmUsedToSign, fullSignaturePayload);
            String receivedSignature =
                    getDetailsFromHmacSignatureHeader(signatureHeader, SIGNATURE_KEY);
            log.debug("Generated HMAC signature is: {}", generatedSignature);
            log.debug("Received HMAC signature is: {}", receivedSignature);

            return receivedSignature.equals(generatedSignature);
        }
        return false;
    }

    private void validateAlgorithmName(String algorithmName) {
        for (HmacAlgorithms hmacAlgorithms : HmacAlgorithms.values()) {
            if (hmacAlgorithms.getName().equals(algorithmName)) {
                return;
            }
        }
        throw new ClientAuthenticationFailedException("Invalid HMAC algorithm: " + algorithmName);
    }

    private String getDetailsFromHmacSignatureHeader(
            String[] signatureHeader, String requiredValue) {
        for (String signature : signatureHeader) {
            String[] value = signature.split(SIGNATURE_HEADER_KEY_VALUE_SEPARATOR);
            if (value.length == 2 && value[0].equals(requiredValue)) {
                return value[1];
            }
        }
        throw new ClientAuthenticationFailedException(
                String.format(
                        "Invalid HMAC signature. Missing key in %s header: %s",
                        MAIN_SIGNATURE_HEADER, requiredValue));
    }

    // the final content that will be used to generate signature contains values from
    // multiple headers, URL and the request payload data separated by new line.
    private String getSignatureValue(String headersInSignature, String webhookUrl, String payload) {
        return """
        %s
        %s
        %s\
        """
                .formatted(headersInSignature, webhookUrl, payload);
    }

    private String groupHeaderValueContent(
            HttpServletRequest httpRequest, String[] signatureHeaders) {
        StringBuilder concatenatedHeaders = new StringBuilder();
        for (String signatureHeader : signatureHeaders) {
            if (Objects.nonNull(httpRequest.getHeader(signatureHeader))) {
                concatenatedHeaders.append(httpRequest.getHeader(signatureHeader));
                concatenatedHeaders.append(SIGNATURE_CONTENT_VALUES_SEPARATOR);
            } else {
                throw new ClientAuthenticationFailedException(
                        "Invalid or missing HMAC header: " + signatureHeader);
            }
        }
        return concatenatedHeaders.toString().trim();
    }

    private String signRequestData(String hmacAlgorithm, String requestData) {
        try {
            Mac mac = Mac.getInstance(hmacAlgorithm);
            SecretKeySpec secretKeySpec =
                    new SecretKeySpec(
                            hmacSecretKey.getBytes(Charset.defaultCharset()), hmacAlgorithm);
            mac.init(secretKeySpec);
            byte[] hmacBytes = mac.doFinal(requestData.getBytes(Charset.defaultCharset()));
            return Hex.encodeHexString(hmacBytes);
        } catch (NoSuchAlgorithmException | InvalidKeyException e) {
            log.error("Failed generating key", e);
            throw new XpanseUnhandledException(e.getMessage());
        }
    }
}
